import Head from "next/head"
import styles from "@/components/styles/Home.module.css"
import Modal from "../components/Modal"
import { useEffect, useState } from 'react'
import * as btc from "@scure/btc-signer"
import * as secp from "@noble/secp256k1"
import { hex } from "@scure/base"

const broadcast = async (txHex) => {
  try {
    const response = await fetch('/api/tx', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ txHex })
    })
    if (response.ok) {
      const data = await response.json()
      console.log(data)
      const txid = data.txid
      return txid
    } else {
      const data = await response.json()
      throw new Error(data.error)
    }
  } catch(error) {
    console.error(error)
  }
}

const getFees = async () => {
  const response = await fetch('https://mempool.space/api/v1/fees/recommended')
  const data = await response.json()
  return data
}

const send = async (privateKey, recipientAddress, amount) => {
  // Derive the sender information
  const senderPublicKey = getPublicKeyFromPrivateKey(privateKey)
  const senderAddress = getAddressFromPublicKey(senderPublicKey)
  // Create the transaction
  const tx = new btc.Transaction()
  // Get the UTXOs from mempool.space
  const response = await fetch(`https://mempool.space/api/address/${senderAddress}/utxo`)
  const data = await response.json()
  // Add the UTXOs as inputs to the transaction
  for (const utxo of data) {
    const inputScript = btc.p2wpkh(secp.getPublicKey(privateKey, true)).script
    tx.addInput({
      txid: utxo.txid,
      index: utxo.vout,
      witnessUtxo: {
        amount: BigInt(utxo.value),
        script: inputScript
      }
    })
  }
  // Add an output to the recipient address
  tx.addOutputAddress(recipientAddress, BigInt(amount))
  console.log(`Unsigned transaction:\n${hex.encode(tx.unsignedTx)}`)
  // Add an output to the sender address
  const numSignatures = 1
  const numNewOutputs = 1
  const txBytes = tx.unsignedTx.length + 31*numNewOutputs + Math.ceil(110/4)*numSignatures
  console.log(txBytes)
  const fees = await getFees()
  const feeRate = fees.fastestFee
  const currentBalance = BigInt(await getBalance(senderAddress))
  const changeAmount = currentBalance - BigInt(amount) - BigInt(feeRate * txBytes)
  console.log(currentBalance)
  console.log(amount)
  console.log(changeAmount)
  tx.addOutputAddress(senderAddress, changeAmount)
  console.log(`Unsigned transaction:\n${hex.encode(tx.unsignedTx)}`)

  // Sign the inputs
  tx.sign(privateKey)
  // Finalize the transaction
  tx.finalize()
  // Return the transaction hex
  const txHex = tx.hex
  return txHex
}

const getBalance = async (address) => {
  // Get API data from mempool.space
  const response = await fetch(`https://mempool.space/api/address/${address}`)
  const data = await response.json()
  // Get the Chain and Mempool stats
  const chainStats = data.chain_stats
  const mempoolStats = data.mempool_stats
  // Calculate the funded sums and spent sums
  const fundedSum = chainStats.funded_txo_sum + mempoolStats.funded_txo_sum
  const spentSum = chainStats.spent_txo_sum + mempoolStats.spent_txo_sum
  // Calculate and return the balance
  const balance = fundedSum - spentSum
  return balance
}

const createPrivateKey = () => {
  const privateKey = secp.utils.randomPrivateKey()
  return privateKey
}

const deriveWallet = (privateKey) => {
  const publicKey = secp.getPublicKey(privateKey, true)
  const scriptInfo = btc.p2wpkh(publicKey)
  const address = scriptInfo.address
  return { publicKey, address }
}

const getPublicKeyFromPrivateKey = (privateKey) => {
  return secp.getPublicKey(privateKey, true)
}

const getAddressFromPublicKey = (publicKey) => {
  const scriptInfo = btc.p2wpkh(publicKey)
  const address = scriptInfo.address
  return address
}

export default function Home() {
  const title = "BitcoinWallet"

  //const newPrivateKey = createPrivateKey()
  //console.log(newPrivateKey)

  const privateKey = hex.decode('dc3e952f42228ab134e416fd889bca28e706ef3b764ac1b024e963cd0ca781b5')
  const { publicKey, address } = deriveWallet(privateKey)

  //console.log(`Private Key: ${hex.encode(privateKey)}`)
  //console.log(`Public Key: ${hex.encode(publicKey)}`)
  //console.log(`Address: ${address}`)

  const [recipient, setRecipient] = useState("")
  const [amount, setAmount] = useState(0)
  const [balance, setBalance] = useState(0)
  const [tx, setTx] = useState("")
  const [txid, setTxid] = useState("")

  useEffect(() => {
    getBalance(address).then((balance) => {
      setBalance(balance)
    })
  }, [balance])

  return (
    <>
      <Head>
        <title>{title}</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Modal
        id="sendModal"
        title="Send"
        action={async () => {
          const newTx = await send(privateKey, recipient, amount)
          console.log(newTx)
          const txid = await broadcast(newTx)
          setTx(newTx)
          setTxid(txid)
        }}
        actionLabel="Send"
        body={
          <>
            <div className="mb-3">
              <label htmlFor="recipient" className="form-label">Recipient</label>
              <input className="form-control" id="recipient" value={recipient} onChange={e => setRecipient(e.target.value)} />
            </div>
            <div className="mb-3">
              <label htmlFor="amount" className="form-label">Amount</label>
              <input className="form-control" id="amount" value={amount} onChange={e => setAmount(e.target.value)} />
            </div>
          </>
        }
      />
      <Modal
        id="receiveModal"
        title="Receive"
        body={
          <>
            <p>Address:</p>
            <p>{address}</p>
          </>
        }
      />
      <main className={styles.main}>
        <h1>BitcoinWallet</h1>

        <div>
          <h1 className="display-1">{balance / 10**8}</h1>
          <h2 className="text-center">BTC</h2>
        </div>

        { tx ? (
          <textarea className="form-control" id="tx" rows="5" value={tx} readOnly></textarea>
        ) : null }

        { txid ? (
          <textarea className="form-control" id="txid" rows="2" value={txid} readOnly></textarea>
        ) : null }

        <div className="d-grid gap-2 col-6 mx-auto">
          <button className="btn btn-primary" type="button"
            data-bs-toggle="modal" data-bs-target="#sendModal">
            Send
          </button>
          <button className="btn btn-secondary" type="button"
            data-bs-toggle="modal" data-bs-target="#receiveModal">
            Receive
          </button>
        </div>

        <div className={styles.grid}>
        </div>
      </main>
    </>
  )
}
